---
section: Journal
title: Designers should code&#58; thoughts from an ex-graphic designer
headline: Explaining complex pharma products with simple and engaging digital stories.
date: December 13, 2017
---

> "Should designers code?" is well-debated question in the digital product industry because it's difficult to apply design sensibility in code without understanding how to code.

Good visual designers have spent a decade practising their craft. They will notice the look, feel and flow of a digital product in emotional and actionable terms. Good developers have spent a decade learning how to simulate programs in their minds. They will notice the programming patterns and platform systems used to make a product.

There's not much left over to think about design sensibility terms when you're simulating a computer in your head. And vice versa, a designer will scream if they find themselves in Vim mode.

Digital designers and software developers are fundamentally divergent. But as a designer who's spent the last eight years programming, if you accept that divergence you lose agency and you won't become a great designer. So here's seven good reasons to code:

## Design is how it works

_"It’s not just what it looks like and feels like. Design is how it works." — Steve Jobs_

Screens are made of code. If you want to be good at designing them, learn how code works. Don't read a book, do it. It's that simple.

## As close and fast as you can get

_“Creators need an immediate connection to what they’re creating." — Bret Victor_

Creators needs tools that have instant feedback. A painter paints, and sees her ideas. A pilot turns and feels g-forces pulling from below. A cook sips the broth. A digital designer should in the very least write CSS (and know how to write it in a maintainable way). It's as close and as fast as you can get to designing screens.

## Mind the gaps

_"The ability to implement your vision is the hallmark of great craftsmanship. It teaches you both the limits and the possibilities of your medium." — David Cole_

If you can’t code it, you have to rely on proxy tooling to give you a best impression. That's fine up to a point, such as when you're prototyping or you're lucky enough to be part of a pizza team with devs you trust. Just don't make the mistake of thinking there isn't a gap between those tools and real code: it can look amazing in Sketch and way off the mark in the browser.

The further you travel at 1 degree off from your target, the further you miss it by. Don't pretend you haven't papered over the gaps.

## Know the way

_"We really need it. Wouldn’t it be easy if we just did it like that? Can you try it real fast?"_

Try programming and you will quickly understand the programmer's quiet rage when someone asks those seemingly innocuous questions using [dirty four letter words](https://m.signalvnoise.com/four-letter-words-f01603fb704c) quoted above. Try writing some code to understand how a seemingly invisible semicolon will break everything. Surprising and contradictory insights are part of the trials of writing software. This is why zen and martial arts metaphors abound in the software development domain.

Walk a mile in their shoes, and you'll realise how different you need to think before you can understand the ways of programming.

---

## Make better products by understanding the necessary overlaps.

A common lesson in all of the above reasons is that understanding gained by doing is the most comprehensive method.

But there's a higher lesson.

In "A City Is Not A Tree", Christopher Alexander describes a living, natural city as a semilattice of interconnected, overlapping elements. In contrast, an artificial city—for example, Canberra—results from an artificial, tree-like organisation without overlaps:

_"no piece of any unit is ever connected to other units, except through the medium of the unit as a whole"_

Like a city, software fails when elements of the whole don't overlap. When designers (and developers) restrict their internal maps to their own domains and can't see that software is made up of ovelapping domains, we lose the rich fabric of interconnections in reality.

Should the designer understand the forces the coder has to deal with? Yes. Should developers know who the product audience is and that aesthetics create emotions? Yes.

So be the curious fox. Or know enough to hire one. The more you're aware of the languages, limits and necessary overlaps of the "hats" within your software creation process, the better chance your digital product stands to resonate with and provide service to real people.
