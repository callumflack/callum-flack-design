---
section: Journal
title: Designers should code
lede: If you want to know how to make software that connects with and works for real people, there's no substitute for shaking hands with the invisible demons programmers wrestle with.
published: December 21, 2017
updated: January 12, 2018
note: Many thanks to Michael Fogleman for his input with this article.
tweet: https://twitter.com/necolas/status/950792091050921985
---

<p class="intro">"Should designers code?" is a well-debated question in the digital product industry because it's difficult to apply fine design sensibility to software products. As a visual designer, the more agency you have in the product design process, the better the product (and more valuable you'll become). That's reason enough to learn to code.</p>

Good visual designers notice the look, feel and flow of a digital product in emotional and actionable terms. Good frontend developers simulate programs in their minds and notice the programming patterns and systems used to make a product. There's not much left over to think about design sensibility when you're simulating a computer in your head. And vice versa, a designer will scream if they find themselves in Vim mode. Digital designers and frontend developers are fundamentally divergent.

However, as a designer who's spent the last eight years programming, I think that if you accept that divergence you lose agency and you won't become a great digital designer. So here's four good reasons for digital designers to code, and one giant lesson in product design:

## Design is how it works

> [It’s not just what it looks like and feels like. Design is how it works.”](http://www.nytimes.com/2003/11/30/magazine/the-guts-of-a-new-machine.html) — Steve Jobs

Let's get this well known concept out of the way first. Screens are made of code. If you want to be good at designing them, learn how code works. Don't read a book, do it. It's that simple.

## As close and fast as you can get

> [Creators need an immediate connection to what they’re creating.”](https://www.theatlantic.com/technology/archive/2017/09/saving-the-world-from-code/540393/) — Bret Victor

Creators needs tools that have instant feedback. A painter paints, and sees her ideas. A pilot turns and feels g-forces pulling from below. A cook sips the broth. A digital designer should in the very least write CSS (and know how to write it in a maintainable way). It's as close and as fast as you can get to designing screens.

## Mind the gaps

> [The ability to implement your vision is the hallmark of great craftsmanship. It teaches you both the limits and the possibilities of your medium.”](https://medium.com/@irondavy/designers-will-code-6c423fc5ccef) — David Cole

If you can’t code it, you have to rely on proxy tooling to give you a best impression. That's fine up to a point, such as when you're prototyping or you're lucky enough to be part of a pizza team with devs you trust, using tried and tested workflows. Just don't make the mistake of thinking there isn't a gap between those tools and real code: it can look amazing in Sketch and way off the mark in the browser.

The further you travel at one degree off from your target, the further you miss it by. Don't pretend you haven't papered over the gaps.

## Know the way

> [We really need it. Wouldn’t it be easy if we just did it like that? Can you try it real fast?”](https://m.signalvnoise.com/four-letter-words-f01603fb704c)

Try programming and you will quickly understand the programmer's quiet rage when someone asks those seemingly innocuous questions using the "dirty four letter words" quoted above. Surprising and contradictory insights are part of the trials of writing software: an unnoticed semicolon will break everything, the error message will be unintelligble. This is why zen and martial arts metaphors abound in the software development domain.

Walk a mile in their shoes, and you'll realise how different you need to think before you can understand the ways of programming.

###### A common lesson in all of the above reasons is that understanding gained by doing is the most comprehensive method of learning.

But there's a higher lesson.

## Make better products by understanding the necessary overlaps.

In "A City Is Not A Tree", Christopher Alexander describes a living, natural city as a semilattice of interconnected, overlapping elements. Think Melbourne, with it's chanced-upon laneways. In contrast, an artificial city—for example, Canberra—results from an artificial, tree-like structure without overlaps, where:

> [no piece of any unit is ever connected to other units, except through the medium of the unit as a whole”](https://books.google.com.au/books?id=k9ovDwAAQBAJ&pg=PT25&lpg=PT25&dq=no+piece+of+any+unit+is+ever+connected+to+other+units,+except+through+the+medium+of+the+unit+as+a+whole&source=bl&ots=lKOqDSgKWY&sig=v-bIPdpnF3pLTd4uQou4AcTW7Bw&hl=en&sa=X&ved=0ahUKEwikyo-Wsd7YAhVJhbwKHfaHBuMQ6AEILDAC#v=onepage&q=no%20piece%20of%20any%20unit%20is%20ever%20connected%20to%20other%20units%2C%20except%20through%20the%20medium%20of%20the%20unit%20as%20a%20whole&f=false)

Like a city, software fails when elements of the whole don't overlap. That disconnect begins in the software making process. When designers (and developers) restrict their internal maps to their own domains and can't see that software is made up of overlapping domains, we lose the rich fabric of interconnections that make great software.

Designers should code so they understand the forces the coder has to deal with (although that doesn't mean they need to be able to handle production-level server-side Javascript!). And by that token, developers should understand they're programming for people who respond emotionally to aesthetics, and not just for the love of programming.

The more you're aware of the contstraints and necessary overlaps of the "hats" within your software creation process, the better chance your digital product stands to resonate with and provide value to real people.
